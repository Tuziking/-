# [子序列中的 k 种字母](https://kamacoder.com/problempage.php?pid=1028)
## 题目描述
一个序列的子序列是指从原序列中选取部分元素，并保持它们在原序列中的相对顺序所形成的新序列。这意味着在子序列中，元素的相对顺序与它们在原序列中的相对顺序保持一致，但不一定要求是连续的。注意，原序列也可以视为自己的子序列。 

现有一个长度为 n 的仅由小写字母组成的字符串 s，求 s 有多少个子序列恰好包含 k 种字母。
## 输入描述
输入仅包含一组测试数据。测试数据包含两行： 

第一行包含两个整数 n 和 k（1 ≤ n ≤ 1000，1 ≤ k ≤ 26），用空格隔开，表示字符串的长度和符合要求的子序列的所需长度。

第二行是一个由小写字母组成的字符串，长度为 n。 
## 输出描述
对于输入的测试数据，输出一个整数，表示计算得到的答案。
## 输入示例
```
6 5
eecbad
```
## 输出示例
```
3
```
## BOBO's 题解
### 解法1：dp
首先需要明确一个事实，对于s中有多少个子序列恰好包含 k 种字母来说，s本身的字母排列顺序并不重要，比如示例中的eecbad中，求解含有5个不同字母的子序列数目，我们只需要保证有2个e，1个c b a d即可。因为对于任何一种顺序来说，并不影响其子序列的数目，那么也就不影响恰好包含k中字母的子序列数目。从这一点出发，我们可以将所有给的s假设为从a开始排列，同时相同字母看为一个整体。
不难看出，恰好包含k种字母的子序列数目，即为每种字母子序列（由于具有相同字母，故每个字母都对应序列，设长度为a，则子序列数目为$2^{n}-1$）之积。于是我们可以设置状态转移方程dp[n] = dp[n-1]*x，x为第n个位置字母的子序列数目。因此我们只需要设置一个26位数组来存储对应字母的出现次数，再使用状态转移方程即可求解。具体查看[代码](main.cpp)
### 解法2：dfs
官方给的题解，但是跑出来结果wrong answer，真神奇。